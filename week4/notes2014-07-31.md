## Data Structures in Java
### Notes for 2014-07-31
Monica Quaintance

mjq2102@columbia.edu

##Homework Notes - for #3

Make your spell check case insensitive, for both problems. For punctuation, 
strip off trailing punctuation (okay to strip trailing apostrophes). Otherwise, match against the dictionary 
directly.

Read the file in, throw the open file into a scanner. Use next line to jump 
through the dictionary (not the case for your file your're checking and not 
the case for the indexing)

Use string tokenizer class to pass, and use 'has more tokens' and 'next token'
-- like an iterator that steps through the string. Can get it to tokenize on 
delimiters 

Method of string has 'substring' so we could use substring, and if it's a special 
character we can strip it off. 

Submit the file you tested #1 on, but be aware it may be run on something else.

##Binary Heap

Looking at code for BinaryHeap.java from Weiss text.

Using array to keep track of the heap. 

Currentsize keeps track of where the last element is.

Initialize to capacity + 1 because we need the 0 spot empty. (Can't divide by 
0.)

Can also make an heap out of an existing array of items by making new 
array, iterating over it, and using buildHeap method.


### Special Purpose Sorting

What if my array has only 0s and 1s? You can just add up the array and then
print a sorted version.

Like a variant on bucket sort. You can do better if you know things about your 
data.

### General Purpose Sorting

Theoretical minimum is Nlog(N) when you don't know anything about you data.

Simple sorting algorithms, comparison based. More complicated like divide and
conquer.

Simple ones: $n^{2}$

Slower, but still somrtimes preferable.

### Selection Sort

Find minimum, put in the first spot. Find the minimum of what's left, put it in
the next location, etc.

Want to do it in a single array--swap first element with new min, then move
over and keep swapping.

[THIS WILL BE A QUESTION ON THE FINAL]

But if your element is already sorted, you have to check all the values anyway.

Comparisons: $n + n - 1 + n - 2 + ... + 1$

$\frac{n(n+1)}{2} = n^{2}/2 + n/2

Best case, worst case, and average case: $O(n^{2})$

Would like an algorithm than in the case of being given a sorted array degrades
into checking (order O(N)).

```java

    int[] ss(int[] a){

      for(int i=0; i < a.length; i++){
        int minsofar=i;

        for(int j = i+1; j < a.length; j++){
          if( a[minsofar] > a[j])
            minsofar = j;
        }
        int t = a[i];
        a[i] = a[minsofar];
        a[minsofar] = t;
      }
    }
```








